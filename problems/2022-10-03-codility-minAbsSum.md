---
title: Codility, Min Abs Sum

date: 2022-10-3

categories:
  - 문제풀이

tags:
  - Exercise
---

# 문제요약

길이가 N인 배열 A가 주어진다. A의 각 요소에 -1 혹은 1을 곱한다. -1 혹은 1이 곱해진 요소의 총합의 절댓값을 최소로 할 때 그 값은 무엇인가?

- N은 0 ~ 20,000
- A의 요소는 -100 ~ 100

# 문제접근

1. 문제를 단순화 하면 배열 A의 각 요소의 부호를 정할 수 있을 때, 총합 절댓값의 최소값을 구하는 것이다. A의 모든 요소가 양수로 주어졌을 때 몇개를 음수로 만들어 총합 절댓값을 최소로 만들라하는 문제와도 같다.

# 시행착오

[실패한 풀이(63%)](https://app.codility.com/demo/results/training87VXH3-R5W/)
그리디한 접근을 해봤다. 가장 큰 수 부터 시작하여 합이 양수이면 빼주고 합이 음수이면 더해주는 알고리즘을 짰다. 엣지케이스가 있는 풀이였다. 예를 들어 [3, 3, 3, 4, 5]가 주어졌을 때 내가 짠 알고리즘은 2를 반환하지만 답은 0이다.

[실패한 풀이(90%)](https://app.codility.com/demo/results/training5ZQUCN-CKM/)
전체 총합을 구한 후 총합의 절반에 가깝도록 요소를 선택하는 알고리즘을 짰다. 선택되는 것은 양수, 선택되지 않는 것은 음수라고 보면 총합의 절댓값을 작게 만들 수 있다고 생각했다.

하지만 총합의 절반을 큰 요소 부터 조회하며 빼가도록 했는데 이것이 항상 최적의 총합의 절반에 다가가는 방법은 아니다. [5, 5, 6, 7]이면 총합의 절반이 11이다. 큰 요소부터 빼면 7과 6을 빼고 끝날 텐데 그러면 3을 반환한다. 하지만 답은 1이다. 

총합의 절반에 최대한 가깝게 만드는 요소를 최적으로 뽑을 수 있는 방법이 없을까?

# [검색결과](https://codility.com/media/train/solution-min-abs-sum.pdf)

공식 풀이가 있어서 살펴봤다. DP 방식으로 접근을 할 수 있다. 요소들로 총합 절반보다 작거나 같으면서, 최대한 총합 절반에 가까운 값이 무엇인지 파악하는 것이 목표이다. 따라서 0, 1, 2 ..., , 총합의 절반 - 2, 총합의 절반 - 1, 총합의 절반 이렇게 DP를 만들어 해당 값을 만들 수 있는지 확인해준다. 

각 배열의 요소가 추가됐을 때, 이전의 요소와 같이 만들 수 있는 값에 만들 수 있는 값이라고 표시해준다. 배열의 요소를 t라고 할 때 DP\[i-t\]를 만들 수 있는 값이면 DP\[i\]도 만들 수 있다. 

    어떤 수를 새로 들어온 요소와 기존에 만들 수 있던 수로 만들 수 있는지 확인해줄 수 있다.

이 문제는 이와 더불어 추가적인 최적화도 필요한 문제이다. 우선은 여기서 만족하고, 다음에 돌아왔을 때 최적화까지 고려해보자.

# [코드]

## 일부 시간초과나는 DP
```javascript
function solution(A) {
    const a = A.map((elem) => Math.abs(elem));
    const sum = a.reduce((pre, cur) => pre + cur, 0);
    const dp = Array(Math.floor(sum / 2) + 1).fill(0);

    dp[0] = 1
    for(let elem of a){
        // 요소를 중복으로 사용할 수 없기 때문에 큰 수부터 거꾸로 확인해줘야함. 
        // 작은 수부터 하면 새로 들어온 요소를 중복으로 사용해서 큰 수를 만드는 경우가 생김.
        for(let i = dp.length - 1; i >= 0; i -= 1){
            if(i-elem >= 0 && dp[i-elem] === 1){
                dp[i] = 1;
            }
        }
    }

    for(let i = dp.length - 1; i >= 0; i -= 1){
        if(dp[i] === 1){
            return sum - (2 * i);
        }
    }
}
```